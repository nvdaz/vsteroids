import math
import os
from argparse import ArgumentParser

from PIL import Image

arg_parser = ArgumentParser()

arg_parser.add_argument("-i", "--image", type=str, required=True)
arg_parser.add_argument("-o", "--outdir", type=str, required=True)
arg_parser.add_argument("-e", "--entity", type=str, required=True, default="bitmap")
arg_parser.add_argument("-r", "--rotations", type=int, default=1)

args = arg_parser.parse_args()

base_image = Image.open(args.image)
base_image = base_image.convert("RGBA")
background = Image.new("RGBA", base_image.size, (0, 0, 0, 255))
base_image = Image.alpha_composite(background, base_image)
original_width, original_height = base_image.width, base_image.height

if args.rotations > 1:
    base_image = base_image.resize(
        (original_width * 10, original_height * 10), resample=Image.Resampling.BICUBIC
    )


if not os.path.exists(args.outdir):
    os.mkdir(args.outdir)

log_rots = math.ceil(math.log2(args.rotations))


def encode_xy(x, y, rot):
    return (x + y * image.width) << log_rots | rot


def encode_rgba(rgba):
    return (
        f"{(rgba[0] // 64):02b}"[::-1]
        + f"{(rgba[1] // 64):02b}"[::-1]
        + f"{(rgba[2] // 64):02b}"[::-1]
    )


log_width = math.ceil(math.log2(base_image.width))

in_bits = math.ceil(math.log2(original_width * original_height))
x_bits = math.ceil(math.log2(original_width))
y_bits = math.ceil(math.log2(original_height))


out = open(os.path.join(args.outdir, f"{args.entity}.vhd"), "w")

pixels = {}
colors = {}
for nrot in range(args.rotations):
    rot = 360 / args.rotations * nrot
    print(rot)

    if args.rotations > 1:
        image = base_image.rotate(rot, fillcolor=(0, 0, 0, 255))
        image = image.resize(
            (
                max(original_width, original_height),
                max(original_width, original_height),
            ),
            resample=Image.Resampling.BICUBIC,
        )
        image = image.convert("P", palette=Image.Palette.ADAPTIVE, colors=4)
        image = image.convert("RGBA")
    else:
        image = base_image

    image = image.convert("P", palette=Image.Palette.ADAPTIVE, colors=2)
    image = image.convert("RGBA")
    image.save(os.path.join(args.outdir, f"{args.entity}_{nrot}.png"))

    for x in range(image.width):
        for y in range(image.height):
            rgba = image.getpixel((x, y))
            if encode_rgba(rgba) not in colors:
                colors[encode_rgba(rgba)] = len(colors) + 1

            pixels[encode_xy(x, y, nrot)] = (x, y, nrot), rgba

if 2 * y_bits - 1 > in_bits - 1:
    ygets = f"x + ymul({in_bits - 1} downto 0)"
elif 2 * y_bits - 1 < in_bits - 1:
    width0 = in_bits - 2 * y_bits
    ygets = f'x + ("{"0" * width0}" & ymul)'
else:
    ygets = "x + ymul"

log_colors = math.ceil(math.log2(len(colors)))

out.write(f"""-- autogenerated from {args.image}
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity {args.entity} is
    port(
        x : in unsigned({x_bits - 1} downto 0); -- 0 to {original_width - 1}
        y : in unsigned({y_bits - 1} downto 0); -- 0 to {original_height - 1}
        {f"rot : in unsigned({log_rots - 1} downto 0);" if args.rotations > 1 else ""}
        rgb : out std_logic_vector(5 downto 0)
    );
end {args.entity};

architecture synth of {args.entity} is

signal ymul : unsigned({2 * y_bits - 1} downto 0);
signal linear_position : unsigned({in_bits - 1} downto 0);

signal color_index : unsigned({log_colors - 1} downto 0);

begin
    ymul <= y * {x_bits}b"{original_width:0b}";
    linear_position <= {ygets}; -- 0 to {original_width*original_height - 1}

    process(all) begin
        case linear_position{" & rot" if args.rotations > 1 else ""} is
""")

for pos, ((x, y, rot), color) in pixels.items():
    out.write(
        f'\t\t\twhen {in_bits + log_rots}x"{pos:0{(in_bits + log_rots) // 4}x}" => color_index <= {log_colors}d"{colors[encode_rgba(color)] -1}"; -- ({x}, {y}, {rot})\n'
    )

out.write(f"""\t\t\twhen others => color_index <= {log_colors}d"0";
        end case;
""")

out.write("""
        case color_index is
""")

for color, index in colors.items():
    out.write(f'\t\t\twhen {log_colors}d"{(index-1)}" => rgb <= "{color}";\n')

out.write("""           when others => rgb <= "000000";
           end case;
    end process;
end synth;
""")


out.close()
